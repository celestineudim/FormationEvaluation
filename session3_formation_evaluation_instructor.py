# -*- coding: utf-8 -*-
"""session3-formation-evaluation-instructor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/yohanesnuwara/python-bootcamp-for-geoengineers/blob/master/EnP_training/session3_formation_evaluation_training.ipynb

# Formation Evaluation with Python
"""

# import numpy, matplotlib, and pandas
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# install and import lasio
!pip install lasio
import lasio

# cloning github repository of formation-evaluation
!git clone https://github.com/yohanesnuwara/formation-evaluation

# import all functions from formation-evaluation
import sys
sys.path.append('/content/formation-evaluation')

from well_log_display import well_log_display
from triple_combo import triple_combo
from ND_plot import ND_plot
from label_generator import label_generator

"""## Functions"""

def calculate_klogh(formation_name, phif, vsh):
  # there is no available equation for Heather Fm. 
  if formation_name == 'hugin':
    return 10 ** (2 + (8 * phif) - (9 * vsh))
  if formation_name == 'sleipner':
    return 10 ** (-3 + (32 * phif) - (2 * vsh))
  if formation_name == 'skagerak':
    return 10 ** (-1.85 + (17.4 * phif) - (3 * vsh))

"""## Load well log data"""

# specify file path (well 15/9-F-11A)
filepath = '/content/formation-evaluation/data/volve/15_9-F-11A.LAS'

# read with lasio
well = lasio.read(filepath)

# check the available logs with .keys()
well.keys()

# look for more detail with .curves
well.curves

# see the data using .data
well.data

# convert it to Pandas dataframe using .df() and then reset index
well = well.df().reset_index()

# then show the dataframe
well.head(10)

"""## Generate formation labels from formation tops file

We have formation tops file. What we are going to do now is to give formation top labels to the logs. We'll use function `label_generator`.
"""

# specify file path
filepath = '/content/formation-evaluation/data/volve/Fmtops_15_9-F-11A.csv'

# read with Pandas
tops = pd.read_csv(filepath)

tops

# see help to find what visualization inputs are required
help(label_generator)

# use "label_generator" to generate formation labels
# then show the dataframe
well = label_generator(well, tops, 'DEPTH', 'FM. LABEL')

well

"""As we see here we have NaN in the `FM. LABEL` column simply because the depths are not corresponding to any Fm. tops. So we can replace NaNs with a string named as `Unknown`"""

# Replace NaNs in formation label column with string called "Unknown"
well['FM. LABEL'] = well['FM. LABEL'].fillna('Unknown')

well

"""## Visualize

### Well-log visualization

We will use function `well_log_display`
"""

# see help to find what visualization inputs are required
# identify which input is OBLIGATORY, which input is OPTIONAL
help(well_log_display)

"""Use default"""

# Logs we gonna visualize are: 'NPHI', 'RHOB', 'GR', 'RT', 'PEF', 'CALI', 'DT', 'DTS' 
df_well = well
column_depth = 'DEPTH'
column_list = ['NPHI', 'RHOB', 'GR', 'RT', 'PEF', 'CALI', 'DT', 'DTS']

well_log_display(df_well, column_depth, column_list)

"""Make the visualization looks better (adding the optional variables)

* Transform the resistivity axis from Cartesian axis to Semilog axis
* Give limits to the x and depth axes (2,600 to 3,500 m)
* Give different colors to each log
"""

column_list

# adding optional variables like "min_depth", "max_depth", etc.
column_semilog=3
min_depth=2600 
max_depth=3500 
column_min=[0, 2, 0, 0.001, 0, 8.5, 50, 100] 
column_max=[0.45, 2.7, 150, 1000, 12.5, 9, 125, 330] 
colors=['black', 'red', 'blue', 'green', 'orange', 'purple', 'gray', 'cyan']  

well_log_display(df_well, column_depth, column_list,
                 column_semilog, min_depth, max_depth,
                 column_min, column_max, colors)

"""### Triple combo

We are seeking hydrocarbon occurence in depth between 3,580 to 3,702 m. So, we'll visualize the crossover in a triple combo. We will use function `triple_combo`
"""

# see help to find what visualization inputs are required
# identify which input is OBLIGATORY, which input is OPTIONAL
help(triple_combo)

"""Use default"""

# triple combo at depth from 3,580 to 3,702 m
df = well
column_depth = 'DEPTH'
column_GR = 'GR'
column_resistivity = 'RT'
column_RHOB = 'RHOB'
column_NPHI = 'NPHI'
min_depth = 3580
max_depth = 3702

triple_combo(df, column_depth, column_GR, column_resistivity,
             column_NPHI, column_RHOB, min_depth, max_depth)

"""Make the visualization looks better (adding the optional variables)

* Give limits to the x axes (specifically, GR and resistivity)
* Give a sand GR line, e.g. 50 API
* Adjust figure size and title height (if needed)
"""

# adding optional variables like "sand_GR_line", "figsize", etc.
min_GR=0
max_GR=125
sand_GR_line=50
min_resistivity=0.1
max_resistivity=1000
title_height=1.01

triple_combo(df, column_depth, column_GR, column_resistivity,
             column_NPHI, column_RHOB, min_depth, max_depth,
             min_GR, max_GR, sand_GR_line, min_resistivity,
             max_resistivity, title_height=title_height)

"""### Neutron Density Plot

We wish to identify the lithologies of each formation (whether sandstone, limestone, or dolomite) using ND plot. We will use function `ND_plot`.
"""

# see help to find what visualization inputs are required
# identify which input is OBLIGATORY, which input is OPTIONAL
help(ND_plot)

"""Plot the NPHI and RHOB points differentiated by each formation names. (categorical)"""

# use "ND_plot" to make a plot with colors based on formation names
denfl = 1
df = well
column_nphi = 'NPHI'
column_rhob = 'RHOB'
column_hue = 'FM. LABEL'
color_by = 'categorical'

ND_plot(denfl, df, column_nphi, column_rhob, column_hue, color_by)

"""Plot NPHI and RHOB points differentiated by depths/other continuous variables"""

# use "ND_plot" to make a plot with colors based on continuous variables
column_hue = 'DT'
color_by = 'continuous'

ND_plot(denfl, df, column_nphi, column_rhob, column_hue, color_by)

"""## Petrophysical Calculation per Formation Top

You already have the data with formation labels. Next we will calculate new petrophysical variables PER FORMATION LABEL (only Heather and Hugin). 

> Sleipner will be your assignment.

First thing we need to do is to "mask the subset of dataframe in FM. LABEL column that contains each of the above names".
"""

# list all formation labels using df['x'].unique()
well['FM. LABEL'].unique()

# create masks for Heather and Hugin using string contains: str.contains.('...')
mask_heather = well['FM. LABEL'].str.contains('Heather')
mask_hugin = well['FM. LABEL'].str.contains('Hugin')

# see inside the mask
mask_heather

"""Now isolate Heather and Hugin into individual subsets of Dataframe, using the masks that we made before."""

# create dataframe subsets of Heather and Hugin: df[mask]
# heather = well[mask_heather]
heather = well[mask_heather]
hugin = well[mask_hugin]

# print the Heather dataframe
heather.head(10)

"""We calculate new petrophysical outputs on these subsets. Based on petrophysical report, each formation has different variables like fluid density ($\rho_{fl}$), etc. The variables have been already listed below."""

# List of individual variables of each formation (DO NOT CHANGE THESE VALUES)
#            Heath  Hugin   Sleip     
rho_ma    = [2.66,  2.65,   2.65]        
rho_fl    = [1,     0.9,    0.9]
gr_min    = [7,     7,      7]
gr_max    = [120,   150,    105]
A         = [0,     0.4,    0.4]  # regression coeff for PHID
B         = [0,     0.01,   0.01] # regression coeff for PHID

# from report, m of Hugin and Sleipner is calculated using specific formula (p. 15, 16)
# now we just assume both has the following values (taken from Asquith, p. 5)
# Hugin is "estimated" as consolidated sst, Sleipner as carbonates
m         = [2,     2,      2.14] 
a         = [1,     1,      1]
n         = [2,     2.45,   2.45]
# water resistivity, already extrapolated at depth from Rw @ 20C = 0.07 ohm-m
Rw        = [0.022, 0.022,  0.022]

"""### 1. Calculate density porosity (PHID)

![image](https://user-images.githubusercontent.com/51282928/98511443-42241880-2297-11eb-94c2-c839ef7a35ba.png)
"""

# calculate PHID for Heather and Hugin
rhob_heather, rhob_hugin = heather['RHOB'], hugin['RHOB']

phid_heather = (rho_ma[0] - rhob_heather) / (rho_ma[0] - rho_fl[0])
phid_hugin = (rho_ma[1] - rhob_hugin) / (rho_ma[1] - rho_fl[1])

phid_hugin

"""### 2. Calculate total porosity (PHIF)"""

# calculate PHIF for Heather and Hugin
# phid + A * (NPHI - phid) + B
nphi_heather, nphi_hugin = heather['NPHI'], hugin['NPHI']

phif_heather = phid_heather + A[0] * (nphi_heather - phid_heather) + B[0]
phif_hugin = phid_hugin + A[1] * (nphi_hugin - phid_hugin) + B[1]

phif_hugin

# display histogram with bins 10
plt.hist(phif_hugin, bins=10)
plt.show()

"""Comment: some porosities are negative. This is normal because there are densities larger than calcite (> 2.71), while the measurement is in lst. unit check: `max(...)`"""

# maximum value of Heather's RHOB
max(rhob_heather)

"""### 3. Calculate shale volume (VSH)

![image](https://user-images.githubusercontent.com/51282928/98511687-ae9f1780-2297-11eb-9d96-9e50631ded03.png)
"""

# calculate VSH for Heather and Hugin
gr_heather, gr_hugin = heather['GR'], hugin['GR']

vsh_heather = (gr_heather - gr_min[0]) / (gr_max[0] - gr_min[0])
vsh_hugin = (gr_hugin - gr_min[1]) / (gr_max[1] - gr_min[1])

vsh_heather

# print summary stats: df.describe()
vsh_heather.describe()

"""### 4. Calculate water saturation (SW)

![image](https://user-images.githubusercontent.com/51282928/98511817-ea39e180-2297-11eb-9919-50d9fb9dc4ea.png)


"""

# calculate SW for Heather and Hugin
rt_heather, rt_hugin = heather['RT'], hugin['RT']

sw_heather = ((a[0] * Rw[0]) / (phif_heather * rt_heather))**(1 / n[0])
sw_hugin = ((a[1] * Rw[1]) / (phif_hugin * rt_hugin))**(1 / n[1])

sw_heather

sw_heather.describe()

"""Comment: In Heather most SW result is larger than 1! 
However this is true because they're in fact water zone.
So, we can mask all SW values larger than 1, to be changed to 1
"""

## create mask
mask_sw_heather = sw_heather <= 1

## change anyting larger than 1 with 1 using the mask
sw_heather = sw_heather[mask_sw_heather]

sw_heather

sw_heather.describe()

"""### Calculate permeability (KLOGH)

The functions have been prepared for you. The equation used are from the report (p. 13), different for each formation.

![image](https://user-images.githubusercontent.com/51282928/98511897-089fdd00-2298-11eb-958b-3c2a05ce13e0.png)
"""

# There is no equation for Heather Fm., so Heather is not calculated
k_hugin = 10**(2 + 8 * phif_hugin - 9 * vsh_hugin)

# display boxplot
plt.boxplot(k_hugin)
plt.ylim(-1,1000)
plt.show()

"""Comment: there are lots of outliers of Hugin permeability

## Visualize calculations result

We have done with calculations, let's visualize them into logs. We will now practice using bare Matplotlib.
"""

# visualize calculation result as derived logs (Hugin)

plt.figure(figsize=(8,10))

depth_hugin = hugin['DEPTH']
logs = [phif_hugin, vsh_hugin, sw_hugin, k_hugin]
titles = ['PHIF', 'VSH', 'SW', 'PERM']
color = ['black', 'red', 'blue', 'green']

for i in range(len(logs)):
  plt.subplot(1,4,i+1)
  plt.plot(logs[i], depth_hugin, color=color[i])
  plt.ylim(max(depth_hugin), min(depth_hugin))
  plt.title(titles[i])

plt.tight_layout(1)
plt.show()

"""## [BONUS] Merge the calculated results to original dataframe

Our data doesn't have columns for PHIF, VSH, SW, and K yet. We first create them.
"""

# create new columns for PHIF, VSH, SW, and K, and initiate with NaNs
# example: df['PHIF'] = np.full(x, np.nan) # where x is length of dataframe

"""Before we created masks for Heather, Hugin, and Sleipner. We'll use it again now to insert all the calculated results to replace the NaNs in the dataframe"""

# apply mask
df.loc[mask_hugin, 'PHIF'] = phif_hugin
df.iloc[9946,:]

"""## End of the training!

Now we know how to:
* Read .LAS file using `lasio` and convert to Pandas dataframe
* Generate formation top labels from formation top file .CSV 
* Visualize well-logs
* Visualize triple combo
* Visualize Neutron-Density plot (with categorical and continuous variables)
* Making subsets of dataframes based on each formation name
* Compute petrophysical variables (PHIF, SW, VSH, K)
* Visualize the results
* Add the computed variables back to our original well log dataframe

## Copyright

`formation-evaluation` repository that stores all the functions and data, and this notebook, are copyrights of Yohanes Nuwara (2020). This notebook is contained in [this repository](https://github.com/yohanesnuwara/python-bootcamp-for-geoengineers) You may freely distribute for self-study and tutorials, but you will consider the authorship of all the codes written here. 

<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
"""